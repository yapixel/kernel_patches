diff --git a/kernel/Kbuild b/kernel/Kbuild
index 540e4709..7a17b8df 100644
--- a/kernel/Kbuild
+++ b/kernel/Kbuild
@@ -3,7 +3,6 @@ kernelsu-objs += allowlist.o
 kernelsu-objs += app_profile.o
 kernelsu-objs += apk_sign.o
 kernelsu-objs += sucompat.o
-kernelsu-objs += syscall_hook_manager.o
 kernelsu-objs += throne_tracker.o
 kernelsu-objs += pkg_observer.o
 kernelsu-objs += setuid_hook.o
diff --git a/kernel/Kconfig b/kernel/Kconfig
index cc4dbb3a..7382012b 100644
--- a/kernel/Kconfig
+++ b/kernel/Kconfig
@@ -1,20 +1,109 @@
 menu "KernelSU"
 
 config KSU
-	tristate "KernelSU function support"
-	depends on KPROBES
-	default y
-	help
-	  Enable kernel-level root privileges on Android System.
-	  Requires CONFIG_KPROBES for kernel hooking support.
-	  To compile as a module, choose M here: the
-	  module will be called kernelsu.
+    tristate "KernelSU function support"
+    default y
+    help
+      Enable kernel-level root privileges on Android System.
+      Requires CONFIG_KPROBES for kernel hooking support.
+      To compile as a module, choose M here: the
+      module will be called kernelsu.
 
 config KSU_DEBUG
-	bool "KernelSU debug mode"
-	depends on KSU
-	default n
-	help
-	  Enable KernelSU debug mode.
+    bool "KernelSU debug mode"
+    depends on KSU
+    default n
+    help
+      Enable KernelSU debug mode.
+
+menu "KernelSU - SUSFS"
+config KSU_SUSFS
+    bool "KernelSU addon - SUSFS"
+    depends on KSU
+    depends on THREAD_INFO_IN_TASK
+    default y
+    help
+        Patch and Enable SUSFS to kernel with KernelSU.
+
+config KSU_SUSFS_SUS_PATH
+    bool "Enable to hide suspicious path (NOT recommended)"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Allow hiding the user-defined path and all its sub-paths from various system calls.
+        - Includes temp fix for the leaks of app path in /sdcard/Android/data directory.
+        - Effective only on zygote spawned user app process.
+        - Use with cautious as it may cause performance loss and will be vulnerable to side channel attacks,
+          just disable this feature if it doesn't work for you or you don't need it at all.
+
+config KSU_SUSFS_SUS_MOUNT
+    bool "Enable to hide suspicious mounts"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Allow hiding the user-defined mount paths from /proc/self/[mounts|mountinfo|mountstat].
+        - Effective on all processes for hiding mount entries.
+        - mnt_id and mnt_group_id of the sus mount will be assigned to a much bigger number to solve the issue of id not being contiguous.
+
+config KSU_SUSFS_SUS_KSTAT
+    bool "Enable to spoof suspicious kstat"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Allow spoofing the kstat of user-defined file/directory.
+        - Effective only on zygote spawned user app process.
+
+config KSU_SUSFS_SPOOF_UNAME
+    bool "Enable to spoof uname"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Allow spoofing the string returned by uname syscall to user-defined string.
+        - Effective on all processes.
+
+config KSU_SUSFS_ENABLE_LOG
+    bool "Enable logging susfs log to kernel"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Allow logging susfs log to kernel, uncheck it to completely disable all susfs log.
+
+config KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS
+    bool "Enable to automatically hide ksu and susfs symbols from /proc/kallsyms"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Automatically hide ksu and susfs symbols from '/proc/kallsyms'.
+        - Effective on all processes.
+
+config KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
+    bool "Enable to spoof /proc/bootconfig (gki) or /proc/cmdline (non-gki)"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Spoof the output of /proc/bootconfig (gki) or /proc/cmdline (non-gki) with a user-defined file.
+        - Effective on all processes.
+
+config KSU_SUSFS_OPEN_REDIRECT
+    bool "Enable to redirect a path to be opened with another path (experimental)"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Allow redirecting a target path to be opened with another user-defined path.
+        - Effective only on processes with uid < 2000.
+        - Please be reminded that process with open access to the target and redirected path can be detected.
+
+config KSU_SUSFS_SUS_MAP
+    bool "Enable to hide some mmapped real file from different proc maps interfaces"
+    depends on KSU_SUSFS
+    default y
+    help
+        - Allow hiding mmapped real file from /proc/<pid>/[maps|smaps|smaps_rollup|map_files|mem|pagemap]
+        - It does NOT support hiding for anon memory.
+        - It does NOT hide any inline hooks or plt hooks cause by the injected library itself.
+        - It may not be able to evade detections by apps that implement a good injection detection.
+        - Effective only on zygote spawned umounted user app process.
+
+endmenu
 
 endmenu
diff --git a/kernel/Makefile b/kernel/Makefile
index 5db16b01..4bb31639 100644
--- a/kernel/Makefile
+++ b/kernel/Makefile
@@ -21,4 +21,13 @@ format:
 check-format:
 	find . \( -name "*.c" -o -name "*.h" \) -print0 | xargs -0 clang-format --dry-run --Werror
 
+## For susfs stuff ##
+ifeq ($(shell test -e $(srctree)/fs/susfs.c; echo $$?),0)
+$(eval SUSFS_VERSION=$(shell cat $(srctree)/include/linux/susfs.h | grep -E '^#define SUSFS_VERSION' | cut -d' ' -f3 | sed 's/"//g'))
+$(info )
+$(info -- SUSFS_VERSION: $(SUSFS_VERSION))
+else
+$(info -- You have not integrated susfs in your kernel yet.)
+$(info -- Read: https://gitlab.com/simonpunk/susfs4ksu)
+endif
 # Keep a new line here!! Because someone may append config
\ No newline at end of file
diff --git a/kernel/allowlist.c b/kernel/allowlist.c
index 6214f4e1..266865e9 100644
--- a/kernel/allowlist.c
+++ b/kernel/allowlist.c
@@ -19,7 +19,9 @@
 #include "selinux/selinux.h"
 #include "allowlist.h"
 #include "manager.h"
+#ifndef CONFIG_KSU_SUSFS
 #include "syscall_hook_manager.h"
+#endif // #ifndef CONFIG_KSU_SUSFS
 #include "su_mount_ns.h"
 
 #define FILE_MAGIC 0x7f4b5355 // ' KSU', u32
@@ -261,8 +263,10 @@ out:
 
 	if (persist) {
 		persistent_allow_list();
+#ifndef CONFIG_KSU_SUSFS
 		// FIXME: use a new flag
 		ksu_mark_running_process();
+#endif // #ifndef CONFIG_KSU_SUSFS
 	}
 
 	return result;
diff --git a/kernel/apk_sign.c b/kernel/apk_sign.c
index 3f9e3a21..a120c78e 100644
--- a/kernel/apk_sign.c
+++ b/kernel/apk_sign.c
@@ -308,5 +308,10 @@ module_param_cb(ksu_debug_manager_appid, &expected_size_ops,
 
 bool is_manager_apk(char *path)
 {
-	return check_v2_signature(path, EXPECTED_MANAGER_SIZE, EXPECTED_MANAGER_HASH);
+#ifndef CONFIG_KSU_SUSFS
+    return check_v2_signature(path, EXPECTED_MANAGER_SIZE, EXPECTED_MANAGER_HASH);
+#else
+    return (check_v2_signature(path, EXPECTED_MANAGER_SIZE, EXPECTED_MANAGER_HASH) ||
+            check_v2_signature(path, 384, "7e0c6d7278a3bb8e364e0fcba95afaf3666cf5ff3c245a3b63c8833bd0445cc4")); // 5ec1cff
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
\ No newline at end of file
diff --git a/kernel/app_profile.c b/kernel/app_profile.c
index b7ec4744..3c211728 100644
--- a/kernel/app_profile.c
+++ b/kernel/app_profile.c
@@ -12,7 +12,9 @@
 #include "klog.h" // IWYU pragma: keep
 #include "selinux/selinux.h"
 #include "su_mount_ns.h"
+#ifndef CONFIG_KSU_SUSFS
 #include "syscall_hook_manager.h"
+#endif // #ifndef CONFIG_KSU_SUSFS
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 7, 0)
 static struct group_info root_groups = { .usage = REFCOUNT_INIT(2) };
@@ -81,8 +83,10 @@ static void disable_seccomp(void)
 void escape_with_root_profile(void)
 {
     struct cred *cred;
+#ifndef CONFIG_KSU_SUSFS
     struct task_struct *p = current;
     struct task_struct *t;
+#endif // #ifndef CONFIG_KSU_SUSFS
 
     cred = prepare_creds();
     if (!cred) {
@@ -133,9 +137,11 @@ void escape_with_root_profile(void)
     spin_unlock_irq(&current->sighand->siglock);
 
     setup_selinux(profile->selinux_domain);
+#ifndef CONFIG_KSU_SUSFS
     for_each_thread (p, t) {
         ksu_set_task_tracepoint_flag(t);
     }
+#endif // #ifndef CONFIG_KSU_SUSFS
 
     setup_mount_ns(profile->namespaces);
 }
diff --git a/kernel/kernel_umount.c b/kernel/kernel_umount.c
index 2087e671..f1ec4b7d 100644
--- a/kernel/kernel_umount.c
+++ b/kernel/kernel_umount.c
@@ -19,6 +19,9 @@
 #include "ksu.h"
 
 static bool ksu_kernel_umount_enabled = true;
+#ifdef CONFIG_KSU_SUSFS
+bool ksu_kernel_umount_enabled = true;
+#endif // #ifdef CONFIG_KSU_SUSFS
 
 static int kernel_umount_feature_get(u64 *value)
 {
@@ -108,6 +111,7 @@ int ksu_handle_umount(uid_t old_uid, uid_t new_uid)
 		return 0;
 	}
 
+#ifndef CONFIG_KSU_SUSFS
     // There are 5 scenarios:
     // 1. Normal app: zygote -> appuid
     // 2. Isolated process forked from zygote: zygote -> isolated_process
@@ -131,6 +135,7 @@ int ksu_handle_umount(uid_t old_uid, uid_t new_uid)
 		pr_info("handle umount ignore non zygote child: %d\n", current->pid);
 		return 0;
 	}
+#endif // #ifndef CONFIG_KSU_SUSFS
 	// umount the target mnt
 	pr_info("handle umount for uid: %d, pid: %d\n", new_uid, current->pid);
 
diff --git a/kernel/ksu.c b/kernel/ksu.c
index 15714a6d..ef0d4297 100644
--- a/kernel/ksu.c
+++ b/kernel/ksu.c
@@ -8,7 +8,9 @@
 #include "feature.h"
 #include "klog.h" // IWYU pragma: keep
 #include "throne_tracker.h"
+#ifndef CONFIG_KSU_SUSFS
 #include "syscall_hook_manager.h"
+#endif // #ifndef CONFIG_KSU_SUSFS
 #include "ksud.h"
 #include "supercalls.h"
 #include "ksu.h"
@@ -36,7 +38,9 @@ int __init kernelsu_init(void)
 
 	ksu_supercalls_init();
 
+#ifndef CONFIG_KSU_SUSFS
 	ksu_syscall_hook_manager_init();
+#endif // #ifndef CONFIG_KSU_SUSFS
 
 	ksu_allowlist_init();
 
diff --git a/kernel/ksud.c b/kernel/ksud.c
index a2017f3d..5d97da29 100644
--- a/kernel/ksud.c
+++ b/kernel/ksud.c
@@ -25,6 +25,9 @@
 #include "util.h"
 #include "selinux/selinux.h"
 #include "throne_tracker.h"
+#ifndef CONFIG_KSU_SUSFS
+#include "syscall_hook_manager.h"
+#endif // #ifndef CONFIG_KSU_SUSFS
 
 bool ksu_module_mounted __read_mostly = false;
 bool ksu_boot_completed __read_mostly = false;
@@ -357,6 +360,9 @@ static int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
 	// we've succeed to insert ksud.rc, now we need to proxy the read and modify the result!
 	// But, we can not modify the file_operations directly, because it's in read-only memory.
 	// We just replace the whole file_operations with a proxy one.
+#ifdef CONFIG_KSU_SUSFS
+	ksu_susfs_set_ops_proxy(file, &fops_proxy, &orig_read, &orig_read_iter, read_proxy, read_iter_proxy);
+#else
 	memcpy(&fops_proxy, file->f_op, sizeof(struct file_operations));
 	orig_read = file->f_op->read;
 	if (orig_read) {
@@ -368,6 +374,7 @@ static int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr,
 	}
 	// replace the file_operations
 	file->f_op = &fops_proxy;
+#endif // #ifdef CONFIG_KSU_SUSFS
 	read_count_append = rc_count;
 
 	*buf_ptr = buf + rc_count;
diff --git a/kernel/ksud.h b/kernel/ksud.h
index 85720d3c..f5ce7a4a 100644
--- a/kernel/ksud.h
+++ b/kernel/ksud.h
@@ -20,4 +20,25 @@ extern u32 ksu_file_sid;
 extern bool ksu_module_mounted;
 extern bool ksu_boot_completed;
 
+#ifdef CONFIG_KSU_SUSFS
+#include <linux/fs.h>
+static inline void ksu_susfs_set_ops_proxy(struct file *file, struct file_operations *fops_proxy,
+				ssize_t (**orig_read)(struct file *, char __user *, size_t, loff_t *),
+				ssize_t (**orig_read_iter)(struct kiocb *, struct iov_iter *),
+				ssize_t (*read_proxy)(struct file *, char __user *, size_t, loff_t *),
+				ssize_t (*read_iter_proxy)(struct kiocb *, struct iov_iter *)) {
+	memcpy(fops_proxy, file->f_op, sizeof(struct file_operations));
+	*orig_read = file->f_op->read;
+	if (*orig_read) {
+		fops_proxy->read = read_proxy;
+	}
+	*orig_read_iter = file->f_op->read_iter;
+	if (*orig_read_iter) {
+		fops_proxy->read_iter = read_iter_proxy;
+	}
+	// replace the file_operations
+	file->f_op = fops_proxy;
+}
+#endif // #ifdef CONFIG_KSU_SUSFS
+
 #endif
diff --git a/kernel/selinux/rules.c b/kernel/selinux/rules.c
index 9c6b8674..6d0a2817 100644
--- a/kernel/selinux/rules.c
+++ b/kernel/selinux/rules.c
@@ -90,6 +90,11 @@ void apply_kernelsu_rules()
     // Allow all binder transactions
     ksu_allow(db, ALL, KERNEL_SU_DOMAIN, "binder", ALL);
 
+#ifdef CONFIG_KSU_SUSFS
+    // For susfs
+    ksu_allow(db, KERNEL_SU_DOMAIN, KERNEL_SU_DOMAIN, "capability", "sys_module");
+#endif // #ifdef CONFIG_KSU_SUSFS
+
     // Allow system server kill su process
     ksu_allow(db, "system_server", KERNEL_SU_DOMAIN, "process", "getpgid");
     ksu_allow(db, "system_server", KERNEL_SU_DOMAIN, "process", "sigkill");
diff --git a/kernel/selinux/selinux.c b/kernel/selinux/selinux.c
index 9dc950d6..425ee70c 100644
--- a/kernel/selinux/selinux.c
+++ b/kernel/selinux/selinux.c
@@ -42,6 +42,23 @@ void setup_selinux(const char *domain)
     }
 }
 
+#ifdef CONFIG_KSU_SUSFS
+u32 ksu_get_sec_context_sid(const char *domain)
+{
+    u32 sid;
+    int error;
+
+    error = security_secctx_to_secid(domain, strlen(domain), &sid);
+    if (error) {
+        pr_info("security_secctx_to_secid %s -> sid: %d, error: %d\n", domain,
+                sid, error);
+        return 0;
+    }
+
+    return sid;
+}
+#endif // #ifdef CONFIG_KSU_SUSFS
+
 void setup_ksu_cred()
 {
     if (ksu_cred && transive_to_domain(KERNEL_SU_CONTEXT, ksu_cred)) {
diff --git a/kernel/selinux/selinux.h b/kernel/selinux/selinux.h
index a7759952..5231cb6b 100644
--- a/kernel/selinux/selinux.h
+++ b/kernel/selinux/selinux.h
@@ -29,6 +29,9 @@ bool is_init(const struct cred *cred);
 void apply_kernelsu_rules();
 
 u32 ksu_get_ksu_file_sid();
+#ifdef CONFIG_KSU_SUSFS
+u32 ksu_get_sec_context_sid(const char *domain);
+#endif // #ifdef CONFIG_KSU_SUSFS
 
 int handle_sepolicy(unsigned long arg3, void __user *arg4);
 
diff --git a/kernel/setuid_hook.c b/kernel/setuid_hook.c
index 60b2c84f..4911ee05 100644
--- a/kernel/setuid_hook.c
+++ b/kernel/setuid_hook.c
@@ -36,7 +36,9 @@
 #include "selinux/selinux.h"
 #include "seccomp_cache.h"
 #include "supercalls.h"
+#ifndef CONFIG_KSU_SUSFS
 #include "syscall_hook_manager.h"
+#endif // #ifndef CONFIG_KSU_SUSFS
 #include "kernel_umount.h"
 
 static bool ksu_enhanced_security_enabled = false;
diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index 00165d3e..dcc99c0b 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -80,6 +80,12 @@ int ksu_handle_faccessat(int *dfd, const char __user **filename_user,
 		return 0;
 	}
 
+#ifdef CONFIG_KSU_SUSFS
+	if (ksu_susfs_is_susfs_id_matched(current_uid().val)) {
+		return 0;
+	}
+#endif // #ifdef CONFIG_KSU_SUSFS
+
 	char path[sizeof(su) + 1];
 	memset(path, 0, sizeof(path));
 	strncpy_from_user_nofault(path, *filename_user, sizeof(path));
@@ -102,6 +108,12 @@ int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
 		return 0;
 	}
 
+#ifdef CONFIG_KSU_SUSFS
+	if (ksu_susfs_is_susfs_id_matched(current_uid().val)) {
+		return 0;
+	}
+#endif // #ifdef CONFIG_KSU_SUSFS
+
 	if (unlikely(!filename_user)) {
 		return 0;
 	}
@@ -135,6 +147,12 @@ int ksu_handle_execve_sucompat(const char __user **filename_user,
 	if (!ksu_is_allow_uid_for_current(current_uid().val))
 		return 0;
 
+#ifdef CONFIG_KSU_SUSFS
+	if (ksu_susfs_is_susfs_id_matched(current_uid().val)) {
+		return 0;
+	}
+#endif // #ifdef CONFIG_KSU_SUSFS
+
 	addr = untagged_addr((unsigned long)*filename_user);
 	fn = (const char __user *)addr;
 	memset(path, 0, sizeof(path));
diff --git a/kernel/sucompat.h b/kernel/sucompat.h
index b60cbde0..1a4ee879 100644
--- a/kernel/sucompat.h
+++ b/kernel/sucompat.h
@@ -10,7 +10,11 @@ void ksu_sucompat_exit(void);
 // Handler functions exported for hook_manager
 int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
                          int *__unused_flags);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(CONFIG_KSU_SUSFS)
+int ksu_handle_stat(int *dfd, struct filename **filename, int *flags);
+#else
 int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
+#endif // #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(CONFIG_KSU_SUSFS)
 int ksu_handle_execve_sucompat(const char __user **filename_user,
                                void *__never_use_argv, void *__never_use_envp,
                                int *__never_use_flags);
diff --git a/kernel/supercalls.c b/kernel/supercalls.c
index 806d0c7f..cded1daf 100644
--- a/kernel/supercalls.c
+++ b/kernel/supercalls.c
@@ -404,6 +404,7 @@ static int do_manage_mark(void __user *arg)
 
 	switch (cmd.operation) {
 	case KSU_MARK_GET: {
+#ifndef CONFIG_KSU_SUSFS
 		// Get task mark status
 		ret = ksu_get_task_mark(cmd.pid);
 		if (ret < 0) {
@@ -412,8 +413,19 @@ static int do_manage_mark(void __user *arg)
 		}
 		cmd.result = (u32)ret;
 		break;
+#else
+        if (susfs_is_current_proc_umounted()) {
+            ret = 0; // SYSCALL_TRACEPOINT is NOT flagged
+        } else {
+            ret = 1; // SYSCALL_TRACEPOINT is flagged
+        }
+        pr_info("manage_mark: ret for pid %d: %d\n", cmd.pid, ret);
+        cmd.result = (u32)ret;
+        break;
+#endif // #ifndef CONFIG_KSU_SUSFS
 	}
 	case KSU_MARK_MARK: {
+#ifndef CONFIG_KSU_SUSFS
 		if (cmd.pid == 0) {
 			ksu_mark_all_process();
 		} else {
@@ -424,9 +436,15 @@ static int do_manage_mark(void __user *arg)
 				return ret;
 			}
 		}
+#else
+        if (cmd.pid != 0) {
+            return ret;
+        }
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	case KSU_MARK_UNMARK: {
+#ifndef CONFIG_KSU_SUSFS
 		if (cmd.pid == 0) {
 			ksu_unmark_all_process();
 		} else {
@@ -437,11 +455,20 @@ static int do_manage_mark(void __user *arg)
 				return ret;
 			}
 		}
+#else
+        if (cmd.pid != 0) {
+            return ret;
+        }
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	case KSU_MARK_REFRESH: {
+#ifndef CONFIG_KSU_SUSFS
 		ksu_mark_running_process();
 		pr_info("manage_mark: refreshed running processes\n");
+#else
+        pr_info("susfs: cmd: KSU_MARK_REFRESH: do nothing\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	default: {
@@ -732,6 +759,7 @@ static void ksu_install_fd_tw_func(struct callback_head *cb)
 	kfree(tw);
 }
 
+#ifndef CONFIG_KSU_SUSFS
 static int reboot_handler_pre(struct kprobe *p, struct pt_regs *regs)
 {
 	struct pt_regs *real_regs = PT_REAL_REGS(regs);
@@ -789,6 +817,121 @@ static struct kprobe reboot_kp = {
 	.symbol_name = REBOOT_SYMBOL,
 	.pre_handler = reboot_handler_pre,
 };
+#else
+int ksu_handle_sys_reboot(int magic1, int magic2, unsigned int cmd, void __user **arg)
+{
+    if (magic1 != KSU_INSTALL_MAGIC1) {
+        return -EINVAL; 
+    }
+
+    // If magic2 is susfs and current process is root
+    if (magic2 == SUSFS_MAGIC && current_uid().val == 0) {
+#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+        if (cmd == CMD_SUSFS_ADD_SUS_PATH) {
+            susfs_add_sus_path(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_ADD_SUS_PATH_LOOP) {
+            susfs_add_sus_path_loop(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_SET_ANDROID_DATA_ROOT_PATH) {
+            susfs_set_i_state_on_external_dir(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_SET_SDCARD_ROOT_PATH) {
+            susfs_set_i_state_on_external_dir(arg);
+            return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_PATH
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+        if (cmd == CMD_SUSFS_HIDE_SUS_MNTS_FOR_ALL_PROCS) {
+            susfs_set_hide_sus_mnts_for_all_procs(arg);
+            return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+        if (cmd == CMD_SUSFS_ADD_SUS_KSTAT) {
+            susfs_add_sus_kstat(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_UPDATE_SUS_KSTAT) {
+            susfs_update_sus_kstat(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_ADD_SUS_KSTAT_STATICALLY) {
+            susfs_add_sus_kstat(arg);
+            return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
+#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+        if (cmd == CMD_SUSFS_SET_UNAME) {
+            susfs_set_uname(arg);
+            return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_SPOOF_UNAME
+#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+        if (cmd == CMD_SUSFS_ENABLE_LOG) {
+            susfs_enable_log(arg);
+            return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_ENABLE_LOG
+#ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
+        if (cmd == CMD_SUSFS_SET_CMDLINE_OR_BOOTCONFIG) {
+            susfs_set_cmdline_or_bootconfig(arg);
+            return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG
+#ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
+        if (cmd == CMD_SUSFS_ADD_OPEN_REDIRECT) {
+            susfs_add_open_redirect(arg);
+            return 0;
+        }
+#endif //#ifdef CONFIG_KSU_SUSFS_OPEN_REDIRECT
+#ifdef CONFIG_KSU_SUSFS_SUS_MAP
+        if (cmd == CMD_SUSFS_ADD_SUS_MAP) {
+            susfs_add_sus_map(arg);
+            return 0;
+        }
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MAP
+        if (cmd == CMD_SUSFS_ENABLE_AVC_LOG_SPOOFING) {
+            susfs_set_avc_log_spoofing(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_SHOW_ENABLED_FEATURES) {
+            susfs_get_enabled_features(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_SHOW_VARIANT) {
+            susfs_show_variant(arg);
+            return 0;
+        }
+        if (cmd == CMD_SUSFS_SHOW_VERSION) {
+            susfs_show_version(arg);
+            return 0;
+        }
+        return 0;
+    }
+
+    // Check if this is a request to install KSU fd
+    if (magic2 == KSU_INSTALL_MAGIC2) {
+        struct ksu_install_fd_tw *tw;
+
+        tw = kzalloc(sizeof(*tw), GFP_ATOMIC);
+        if (!tw)
+            return 0;
+
+        tw->outp = (int __user *)(*arg);
+        tw->cb.func = ksu_install_fd_tw_func;
+
+        if (task_work_add(current, &tw->cb, TWA_RESUME)) {
+            kfree(tw);
+            pr_warn("install fd add task_work failed\n");
+        }
+    }
+    return 0;
+}
+#endif // #ifndef CONFIG_KSU_SUSFS
 
 void ksu_supercalls_init(void)
 {
@@ -800,17 +943,23 @@ void ksu_supercalls_init(void)
                 ksu_ioctl_handlers[i].cmd);
     }
 
+#ifndef CONFIG_KSU_SUSFS
 	int rc = register_kprobe(&reboot_kp);
 	if (rc) {
 		pr_err("reboot kprobe failed: %d\n", rc);
 	} else {
 		pr_info("reboot kprobe registered successfully\n");
 	}
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 void ksu_supercalls_exit(void)
 {
+#ifndef CONFIG_KSU_SUSFS
     unregister_kprobe(&reboot_kp);
+#else
+    pr_info("susfs: do nothing\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 // IOCTL dispatcher
