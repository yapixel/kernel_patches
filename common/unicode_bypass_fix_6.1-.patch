diff --git a/fs/unicode/utf8-norm.c b/fs/unicode/utf8-norm.c
index 768f8ab448b8f..7d19000effd85 100644
--- a/fs/unicode/utf8-norm.c
+++ b/fs/unicode/utf8-norm.c
@@ -693,21 +693,21 @@
 		if (utf8agetab[LEAF_GEN(leaf)] > u8c->data->maxage) {
 			ccc = STOPPER;
 		} else if (ccc == DECOMPOSE) {
-			u8c->len -= utf8clen(u8c->s);
-			u8c->p = u8c->s + utf8clen(u8c->s);
-			u8c->s = LEAF_STR(leaf);
-			/* Empty decomposition implies CCC 0. */
-			if (*u8c->s == '\0') {
-				if (u8c->ccc == STOPPER)
-					continue;
+			// Check if the decomposition result is empty (e.g., zero-width space)
+			if (*LEAF_STR(leaf) == '\0') {
 				ccc = STOPPER;
-				goto ccc_mismatch;
+			} else {
+				// Pointer movement and state modification are performed only when it is confirmed that the character is a normal character that needs to be decomposed.
+				u8c->len -= utf8clen(u8c->s);
+				u8c->p = u8c->s + utf8clen(u8c->s);
+				u8c->s = LEAF_STR(leaf);
+				
+				// Proceed to the next level of searching
+				leaf = utf8lookup(u8c->data, u8c->hangul, u8c->s);
+				if (!leaf)
+					return -1;
+				ccc = LEAF_CCC(leaf);
 			}
-
-			leaf = utf8lookup(u8c->data, u8c->hangul, u8c->s);
-			if (!leaf)
-				return -1;
-			ccc = LEAF_CCC(leaf);
 		}
 
 		/*
