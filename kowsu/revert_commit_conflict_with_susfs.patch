From 3a5fc3fc54808ad18401aa5d2a8c7ef2cb79473b Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 09:54:21 +0800
Subject: [PATCH 01/11] Revert "ksud: add wipe umount list cmd"

This reverts commit 04139a68658e4a7e207860b582957ae2d86d124d.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 userspace/ksud/src/cli.rs | 11 -----------
 1 file changed, 11 deletions(-)

diff --git a/userspace/ksud/src/cli.rs b/userspace/ksud/src/cli.rs
index 4c3e9c17..aba77698 100644
--- a/userspace/ksud/src/cli.rs
+++ b/userspace/ksud/src/cli.rs
@@ -31,9 +31,6 @@ enum Commands {
         command: Module,
     },
 
-    /// Wipe the umount list
-    WipeUmountList,
-
     /// Add custom try umount path
     AddTryUmount {  
         path: PathBuf,  
@@ -331,14 +328,6 @@ pub fn run() -> Result<()> {
                 Module::List => module::list_modules(),
             }
         }
-	Commands::WipeUmountList => {  
-	    let mut dummy: u32 = 0;  
-	    unsafe {  
-		libc::prctl(0xDEADBEEFu32 as i32, 10000, 0, 0, &mut dummy as *mut u32 as libc::c_ulong);  
-	     }
-             Ok(())  
-	}
-
 	Commands::AddTryUmount { path } => {  
 	    match CString::new(path.to_string_lossy().as_ref()) {  
 		std::result::Result::Ok(c_path) => {  
-- 
2.51.1.dirty


From 654e9537b24450da5cdfe8e2b5b8098c9ea03bef Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 09:57:15 +0800
Subject: [PATCH 02/11] Revert "ksud: add cmd for add-try-umount (5ec1cff#16)"

This reverts commit 1c58a3836d3a7e112bb1690256afd53348035610.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 userspace/ksud/src/cli.rs | 20 --------------------
 1 file changed, 20 deletions(-)

diff --git a/userspace/ksud/src/cli.rs b/userspace/ksud/src/cli.rs
index aba77698..934148d9 100644
--- a/userspace/ksud/src/cli.rs
+++ b/userspace/ksud/src/cli.rs
@@ -31,10 +31,6 @@ enum Commands {
         command: Module,
     },
 
-    /// Add custom try umount path
-    AddTryUmount {  
-        path: PathBuf,  
-    },
 
     /// Nuke custom ext4 sysfs path
     NukeExt4Sysfs {
@@ -328,22 +324,6 @@ pub fn run() -> Result<()> {
                 Module::List => module::list_modules(),
             }
         }
-	Commands::AddTryUmount { path } => {  
-	    match CString::new(path.to_string_lossy().as_ref()) {  
-		std::result::Result::Ok(c_path) => {  
-		    let mut dummy: u32 = 0;  
-		    unsafe {  
-		        libc::prctl(0xDEADBEEFu32 as i32, 10001, c_path.as_ptr() as libc::c_ulong,   
-		                   &mut dummy as *mut u32 as libc::c_ulong,   
-		                   &mut dummy as *mut u32 as libc::c_ulong);  
-		    }  
-		}  
-		std::result::Result::Err(e) => {  
-		    eprintln!("Failed to create CString: {}", e);  
-		}  
-	    }  
-	    Ok(())  
-	}
 	Commands::NukeExt4Sysfs { path } => {  
 	    match CString::new(path.to_string_lossy().as_ref()) {  
 		std::result::Result::Ok(c_path) => {  
-- 
2.51.1.dirty


From a77c760071f7c3d35c927d72903b5e7fb9c1d0a1 Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:00:17 +0800
Subject: [PATCH 03/11] Revert "kernel: core_hook: add support for KernelNoSU
 v2"

This reverts commit 3041115f1c75e54af198f555f70553e309b47826.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/core_hook.c | 75 ++++++++++++++++++++++++----------------------
 1 file changed, 39 insertions(+), 36 deletions(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index d566d14e..d28c3873 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -296,42 +296,6 @@ skip_check:
 	if (KERNEL_SU_OPTION != option)
 		return 0;
 
-#ifdef CONFIG_KSU_DEBUG
-	pr_info("option: 0x%x, cmd: %ld\n", option, arg2);
-#endif
-
-	if (arg2 == CMD_GRANT_ROOT) {
-		pr_info("allow root for: %d\n", current_uid().val);
-		escape_to_root();
-		if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
-			pr_err("grant_root: prctl reply error\n");
-		}
-		return 0;
-	}
-
-	if (arg2 == CMD_ENABLE_SU) {
-		bool enabled = (arg3 != 0);
-		if (enabled == ksu_su_compat_enabled) {
-			pr_info("cmd enable su but no need to change.\n");
-			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {// return the reply_ok directly
-				pr_err("prctl reply error, cmd: %lu\n", arg2);
-			}
-			return 0;
-		}
-
-		if (enabled) {
-			ksu_sucompat_init();
-		} else {
-			ksu_sucompat_exit();
-		}
-		ksu_su_compat_enabled = enabled;
-
-		if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
-			pr_err("prctl reply error, cmd: %lu\n", arg2);
-		}
-		return 0;
-	}
-
 	// just continue old logic
 	bool from_root = !current_uid().val;
 	bool from_manager = is_manager();
@@ -341,6 +305,10 @@ skip_check:
 		return 0;
 	}
 
+#ifdef CONFIG_KSU_DEBUG
+	pr_info("option: 0x%x, cmd: %ld\n", option, arg2);
+#endif
+
 	if (arg2 == CMD_WIPE_UMOUNT_LIST) {
 		struct mount_entry *entry, *tmp;
 		list_for_each_entry_safe(entry, tmp, &mount_list, list) {
@@ -447,6 +415,17 @@ skip_check:
 		return 0;
 	}
 
+	if (arg2 == CMD_GRANT_ROOT) {
+		if (is_allow_su()) {
+			pr_info("allow root for: %d\n", current_uid().val);
+			escape_to_root();
+			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
+				pr_err("grant_root: prctl reply error\n");
+			}
+		}
+		return 0;
+	}
+
 	// Both root manager and root processes should be allowed to get version
 	if (arg2 == CMD_GET_VERSION) {
 		u32 version = KERNEL_SU_VERSION;
@@ -629,6 +608,30 @@ skip_check:
 		return 0;
 	}
 
+	if (arg2 == CMD_ENABLE_SU) {
+		bool enabled = (arg3 != 0);
+		if (enabled == ksu_su_compat_enabled) {
+			pr_info("cmd enable su but no need to change.\n");
+			if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {// return the reply_ok directly
+				pr_err("prctl reply error, cmd: %lu\n", arg2);
+			}
+			return 0;
+		}
+
+		if (enabled) {
+			ksu_sucompat_init();
+		} else {
+			ksu_sucompat_exit();
+		}
+		ksu_su_compat_enabled = enabled;
+
+		if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
+			pr_err("prctl reply error, cmd: %lu\n", arg2);
+		}
+
+		return 0;
+	}
+
 	if (arg2 == CMD_IS_AVC_SPOOF_ENABLED) {
 		if (copy_to_user(arg3, &ksu_avc_spoof_enabled, sizeof(ksu_avc_spoof_enabled))) {
 			pr_err("copy avc spoof failed\n");
-- 
2.51.1.dirty


From b32a89a0aa6e7ab3171938548a81b029edfb81cf Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:00:35 +0800
Subject: [PATCH 04/11] Revert "kernel: harden barriers for arm/arm64"

This reverts commit f3c8d379525ee65637d0b8ae15012e48ac2ccdc1.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/core_hook.c     | 2 +-
 kernel/kernel_compat.h | 8 --------
 kernel/sucompat.c      | 2 +-
 3 files changed, 2 insertions(+), 10 deletions(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index d28c3873..3b07ab39 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -287,7 +287,7 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 skip_check:
 	// yes this causes delay, but this keeps the delay consistent, which is what we want
 	// with a barrier for safety as the compiler might try to do something smart.
-	DONT_GET_SMART();
+	barrier();
 	if (!is_allow_su())
 		return 0;
 
diff --git a/kernel/kernel_compat.h b/kernel/kernel_compat.h
index 249413b9..c78948d1 100644
--- a/kernel/kernel_compat.h
+++ b/kernel/kernel_compat.h
@@ -20,14 +20,6 @@
 #endif
 #endif
 
-#if defined(CONFIG_ARM) || defined(CONFIG_ARM64)
-// arch/arm64/include/asm/barrier.h, adding dsb probably unneeded
-#define DONT_GET_SMART() do { barrier(); isb(); } while (0)
-#else
-// well, compiler atleast, and not our targets
-#define DONT_GET_SMART() barrier()
-#endif
-
 extern long ksu_strncpy_from_user_nofault(char *dst,
 					  const void __user *unsafe_addr,
 					  long count);
diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index b421fc2b..0fd03760 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -49,7 +49,7 @@ static char __user *ksud_user_path(void)
 __attribute__((hot, no_stack_protector))
 static __always_inline bool is_su_allowed(const void *ptr_to_check)
 {
-	DONT_GET_SMART();
+	barrier();
 
 	if (likely(!ksu_is_allow_uid(current_uid().val)))
 		return false;
-- 
2.51.1.dirty


From 18d1ba54807cffbe57e62ec9807c04a3adf37d76 Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:00:41 +0800
Subject: [PATCH 05/11] Revert "kernel: core_hook: harden prctl handler"

This reverts commit f41a65f4acef03ebb36ef82e523470c9ed2a462d.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/core_hook.c | 30 +++++++++---------------------
 1 file changed, 9 insertions(+), 21 deletions(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index 3b07ab39..879f4ff9 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -272,32 +272,20 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 	// if success, we modify the arg5 as result!
 	u32 *result = (u32 *)arg5;
 	u32 reply_ok = KERNEL_SU_OPTION;
-	uid_t current_uid_val = current_uid().val;
 
-	// skip this private space support if uid below 100k
-	if (current_uid_val < 100000)
-		goto skip_check;
+	if (KERNEL_SU_OPTION != option) {
+		return 0;
+	}
 
+	// TODO: find it in throne tracker!
+	uid_t current_uid_val = current_uid().val;
 	uid_t manager_uid = ksu_get_manager_uid();
-	if (current_uid_val != manager_uid && 
-		current_uid_val % 100000 == manager_uid) {
-			ksu_set_manager_uid(current_uid_val);
+	if (current_uid_val != manager_uid &&
+	    current_uid_val % 100000 == manager_uid) {
+		ksu_set_manager_uid(current_uid_val);
 	}
 
-skip_check:
-	// yes this causes delay, but this keeps the delay consistent, which is what we want
-	// with a barrier for safety as the compiler might try to do something smart.
-	barrier();
-	if (!is_allow_su())
-		return 0;
-
-	// we move it after uid check here so they cannot
-	// compare 0xdeadbeef call to a non-0xdeadbeef call
-	if (KERNEL_SU_OPTION != option)
-		return 0;
-
-	// just continue old logic
-	bool from_root = !current_uid().val;
+	bool from_root = 0 == current_uid().val;
 	bool from_manager = is_manager();
 
 	if (!from_root && !from_manager) {
-- 
2.51.1.dirty


From 3d16a03dcebb86e1f76cd6bf266e1a7a0989a9dd Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:00:47 +0800
Subject: [PATCH 06/11] Revert "kernel: sucompat: add kretprobes-hooked
 getname_flags for sucompat"

This reverts commit b319cf3738a231ce71a25dd9a83cea602b55eac4.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/sucompat.c | 88 +++++++++--------------------------------------
 1 file changed, 16 insertions(+), 72 deletions(-)

diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index 0fd03760..218c6c12 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -162,6 +162,12 @@ int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
 
 	return ksu_sucompat_kernel_common((void *)(*filename_ptr)->name, "do_execveat_common", true);
 }
+
+int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
+			void *envp, int *flags)
+{
+	return ksu_handle_execveat_sucompat(fd, filename_ptr, argv, envp, flags);
+}
 #else
 // for do_execve_common on < 3.14
 // take note: char **filename
@@ -214,7 +220,7 @@ int ksu_handle_devpts(struct inode *inode)
 }
 
 #ifdef CONFIG_KPROBES
-#if 0
+
 static int faccessat_handler_pre(struct kprobe *p, struct pt_regs *regs)
 {
 	struct pt_regs *real_regs = PT_REAL_REGS(regs);
@@ -246,7 +252,6 @@ static int execve_handler_pre(struct kprobe *p, struct pt_regs *regs)
 	return ksu_handle_execve_sucompat(AT_FDCWD, filename_user, NULL, NULL,
 					  NULL);
 }
-#endif
 
 static int pts_unix98_lookup_pre(struct kprobe *p, struct pt_regs *regs)
 {
@@ -287,87 +292,26 @@ static void destroy_kprobe(struct kprobe **kp_ptr)
 	*kp_ptr = NULL;
 }
 
-static DEFINE_MUTEX(ksu_rp_sucompat_lock);
-static struct kretprobe *getname_rp;
-static struct kprobe *devpts_kp;
-
-static int getname_flags_ret_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
-{
-	int *flags = (int *)ri->data;
-
-	struct filename *ret = (struct filename *)PT_REGS_RC(regs);
-	if (IS_ERR(ret) || !ret || !ret->name)
-		return 0;
-
-	ksu_getname_flags_kernel((char **)&ret->name, *flags);
-	return 0;
-}
-
-static int getname_flags_entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)
-{
-	int *flags = (int *)ri->data; // as per sample, we store everything on ri->data ?
-	*flags = (int)PT_REGS_PARM2(regs); // keep a copy of arg2
-
-	return 0;
-}
-
-static struct kretprobe *init_kretprobe(const char *symbol,
-					kretprobe_handler_t entry_handler,
-					kretprobe_handler_t ret_handler,
-					size_t data_size,
-					int maxactive)
-{
-	struct kretprobe *rp = kzalloc(sizeof(struct kretprobe), GFP_KERNEL);
-	if (!rp)
-		return NULL;
-
-	rp->kp.symbol_name = symbol;
-	rp->entry_handler = entry_handler;
-	rp->handler = ret_handler;
-	rp->data_size = data_size;
-	rp->maxactive = maxactive;
-
-	mutex_lock(&ksu_rp_sucompat_lock);
-	int ret = register_kretprobe(rp);
-	mutex_unlock(&ksu_rp_sucompat_lock);
-	if (ret) {
-		kfree(rp);
-		return NULL;
-	}
-	pr_info("rp_sucompat: planted kretprobe at %s: %p\n", rp->kp.symbol_name, rp->kp.addr);
-
-	return rp;
-}
-
-static void destroy_kretprobe(struct kretprobe **rp_ptr)
-{
-	if (!rp_ptr || !*rp_ptr)
-		return;
-
-	mutex_lock(&ksu_rp_sucompat_lock);
-	unregister_kretprobe(*rp_ptr);
-	mutex_unlock(&ksu_rp_sucompat_lock);
-	kfree(*rp_ptr);
-	*rp_ptr = NULL;
-}
+static struct kprobe *su_kps[4];
 #endif
 
 // sucompat: permited process can execute 'su' to gain root access.
 void ksu_sucompat_init()
 {
 #ifdef CONFIG_KPROBES
-	devpts_kp = init_kprobe("pts_unix98_lookup", pts_unix98_lookup_pre);
-	pr_info("%s: register getname_flags!\n", __func__);
-	getname_rp = init_kretprobe("getname_flags", getname_flags_entry_handler,
-			getname_flags_ret_handler, sizeof(int), 20);
+	su_kps[0] = init_kprobe(SYS_EXECVE_SYMBOL, execve_handler_pre);
+	su_kps[1] = init_kprobe(SYS_FACCESSAT_SYMBOL, faccessat_handler_pre);
+	su_kps[2] = init_kprobe(SYS_NEWFSTATAT_SYMBOL, newfstatat_handler_pre);
+	su_kps[3] = init_kprobe("pts_unix98_lookup", pts_unix98_lookup_pre);
 #endif
 }
 
 void ksu_sucompat_exit()
 {
 #ifdef CONFIG_KPROBES
-	pr_info("rp_sucompat: unregister getname_flags!\n");
-	destroy_kretprobe(&getname_rp);
-	destroy_kprobe(&devpts_kp);
+	int i;
+	for (i = 0; i < ARRAY_SIZE(su_kps); i++) {
+		destroy_kprobe(&su_kps[i]);
+	}
 #endif
 }
-- 
2.51.1.dirty


From 7de6aa54601a38c2c152628026f7f64dd08e893d Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:00:53 +0800
Subject: [PATCH 07/11] Revert "kerrnel: overhaul sucompat"

This reverts commit 382310d6df22d4d14b1b89f7e14085812e36a78b.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/sucompat.c | 178 +++++++++++++++++++---------------------------
 1 file changed, 74 insertions(+), 104 deletions(-)

diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index 218c6c12..ae57becc 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -45,155 +45,125 @@ static char __user *ksud_user_path(void)
 	return userspace_stack_buffer(ksud_path, sizeof(ksud_path));
 }
 
-// every little bit helps here
-__attribute__((hot, no_stack_protector))
-static __always_inline bool is_su_allowed(const void *ptr_to_check)
+int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
+			 int *__unused_flags)
 {
-	barrier();
+	const char su[] = SU_PATH;
+
+	if (!ksu_is_allow_uid(current_uid().val)) {
+		return 0;
+	}
 
-	if (likely(!ksu_is_allow_uid(current_uid().val)))
-		return false;
+	char path[sizeof(su) + 1];
+	memset(path, 0, sizeof(path));
+	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));
 
-	if (unlikely(!ptr_to_check))
-		return false;
+	if (unlikely(!memcmp(path, su, sizeof(su)))) {
+		pr_info("faccessat su->sh!\n");
+		*filename_user = sh_user_path();
+	}
 
-	return true;
+	return 0;
 }
 
-static int ksu_sucompat_user_common(const char __user **filename_user,
-				const char *syscall_name,
-				const bool escalate)
+int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
 {
+	// const char sh[] = SH_PATH;
 	const char su[] = SU_PATH;
 
-	char path[sizeof(su)]; // sizeof includes nullterm already!
-	if (ksu_copy_from_user_retry(path, *filename_user, sizeof(path)))
+	if (!ksu_is_allow_uid(current_uid().val)) {
 		return 0;
+	}
 
-	path[sizeof(path) - 1] = '\0';
+	if (unlikely(!filename_user)) {
+		return 0;
+	}
 
-	if (memcmp(path, su, sizeof(su)))
+	char path[sizeof(su) + 1];
+	memset(path, 0, sizeof(path));
+// Remove this later!! we use syscall hook, so this will never happen!!!!!
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0) && 0
+	// it becomes a `struct filename *` after 5.18
+	// https://elixir.bootlin.com/linux/v5.18/source/fs/stat.c#L216
+	const char sh[] = SH_PATH;
+	struct filename *filename = *((struct filename **)filename_user);
+	if (IS_ERR(filename)) {
+		return 0;
+	}
+	if (likely(memcmp(filename->name, su, sizeof(su))))
 		return 0;
+	pr_info("vfs_statx su->sh!\n");
+	memcpy((void *)filename->name, sh, sizeof(sh));
+#else
+	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));
 
-	if (escalate) {
-		pr_info("%s su found\n", syscall_name);
-		*filename_user = ksud_user_path();
-		escape_to_root(); // escalate !!
-	} else {
-		pr_info("%s su->sh!\n", syscall_name);
+	if (unlikely(!memcmp(path, su, sizeof(su)))) {
+		pr_info("newfstatat su->sh!\n");
 		*filename_user = sh_user_path();
 	}
+#endif
 
 	return 0;
 }
 
-// sys_faccessat
-int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
-			 int *__unused_flags)
+// the call from execve_handler_pre won't provided correct value for __never_use_argument, use them after fix execve_handler_pre, keeping them for consistence for manually patched code
+int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
+				 void *__never_use_argv, void *__never_use_envp,
+				 int *__never_use_flags)
 {
-	if (!is_su_allowed((const void *)filename_user))
-		return 0;
-
-	return ksu_sucompat_user_common(filename_user, "faccessat", false);
-}
+	struct filename *filename;
+	const char sh[] = KSUD_PATH;
+	const char su[] = SU_PATH;
 
-// sys_newfstatat, sys_fstat64
-int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
-{
-	if (!is_su_allowed((const void *)filename_user))
+	if (unlikely(!filename_ptr))
 		return 0;
 
-	return ksu_sucompat_user_common(filename_user, "newfstatat", false);
-}
-
-// sys_execve, compat_sys_execve
-int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
-			       void *__never_use_argv, void *__never_use_envp,
-			       int *__never_use_flags)
-{
-	if (!is_su_allowed((const void *)filename_user))
+	filename = *filename_ptr;
+	if (IS_ERR(filename)) {
 		return 0;
+	}
 
-	return ksu_sucompat_user_common(filename_user, "sys_execve", true);
-}
-
-// getname_flags on fs/namei.c, this hooks ALL fs-related syscalls.
-// NOT RECOMMENDED for daily use. mostly for debugging purposes.
-int ksu_getname_flags_user(const char __user **filename_user, int flags)
-{
-	if (!is_su_allowed((const void *)filename_user))
+	if (likely(memcmp(filename->name, su, sizeof(su))))
 		return 0;
 
-	// sys_execve always calls getname, which sets flags = 0 on getname_flags
-	// we can use it to deduce if caller is likely execve
-	return ksu_sucompat_user_common(filename_user, "getname_flags", !!!flags);
-}
+	if (!ksu_is_allow_uid(current_uid().val))
+		return 0;
 
-static int ksu_sucompat_kernel_common(void *filename_ptr, const char *function_name, bool escalate)
-{
+	pr_info("do_execveat_common su found\n");
+	memcpy((void *)filename->name, sh, sizeof(sh));
 
-	if (likely(memcmp(filename_ptr, SU_PATH, sizeof(SU_PATH))))
-		return 0;
+	escape_to_root();
 
-	if (escalate) {
-		pr_info("%s su found\n", function_name);
-		memcpy(filename_ptr, KSUD_PATH, sizeof(KSUD_PATH));
-		escape_to_root();
-	} else {
-		pr_info("%s su->sh\n", function_name);
-		memcpy(filename_ptr, SH_PATH, sizeof(SH_PATH));
-	}
 	return 0;
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 14, 0)
-// for do_execveat_common / do_execve_common on >= 3.14
-// take note: struct filename **filename
-int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
-				 void *__never_use_argv, void *__never_use_envp,
-				 int *__never_use_flags)
+int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
+			       void *__never_use_argv, void *__never_use_envp,
+			       int *__never_use_flags)
 {
-	if (!is_su_allowed((const void *)filename_ptr))
+	const char su[] = SU_PATH;
+	char path[sizeof(su) + 1];
+
+	if (unlikely(!filename_user))
 		return 0;
 
-	// struct filename *filename = *filename_ptr;
-	// return ksu_do_execveat_common((void *)filename->name, "do_execveat_common");
-	// nvm this, just inline
+	memset(path, 0, sizeof(path));
+	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));
 
-	return ksu_sucompat_kernel_common((void *)(*filename_ptr)->name, "do_execveat_common", true);
-}
+	if (likely(memcmp(path, su, sizeof(su))))
+		return 0;
 
-int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv,
-			void *envp, int *flags)
-{
-	return ksu_handle_execveat_sucompat(fd, filename_ptr, argv, envp, flags);
-}
-#else
-// for do_execve_common on < 3.14
-// take note: char **filename
-int ksu_legacy_execve_sucompat(const char **filename_ptr,
-				 void *__never_use_argv,
-				 void *__never_use_envp)
-{
-	if (!is_su_allowed((const void *)filename_ptr))
+	if (!ksu_is_allow_uid(current_uid().val))
 		return 0;
 
-	return ksu_sucompat_kernel_common((void *)*filename_ptr, "do_execve_common", true);
-}
-#endif
+	pr_info("sys_execve su found\n");
+	*filename_user = ksud_user_path();
 
-// getname_flags on fs/namei.c, this hooks ALL fs-related syscalls.
-// put the hook right after usercopy
-// NOT RECOMMENDED for daily use. mostly for debugging purposes.
-int ksu_getname_flags_kernel(char **kname, int flags)
-{
-	if (!is_su_allowed((const void *)kname))
-		return 0;
+	escape_to_root();
 
-	return ksu_sucompat_kernel_common((void *)*kname, "getname_flags", !!!flags);
+	return 0;
 }
 
-
 int ksu_handle_devpts(struct inode *inode)
 {
 	if (!current->mm) {
-- 
2.51.1.dirty


From 69aa9be5c9bb829ab146dec0ed3816f7ba809fa1 Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:01:03 +0800
Subject: [PATCH 08/11] Revert "kernel: core_hook: only umount when unmountable
 > 0"

This reverts commit 2ea2081f9c609a9d4162a02cb771bb05460be7fc.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/core_hook.c | 6 ------
 1 file changed, 6 deletions(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index 879f4ff9..bd699399 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -47,7 +47,6 @@
 #include "kernel_compat.h"
 
 static bool ksu_module_mounted = false;
-static unsigned int ksu_unmountable_count = 0;
 
 extern int handle_sepolicy(unsigned long arg3, void __user *arg4);
 
@@ -347,7 +346,6 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 		// debug
 		// pr_info("cmd_add_try_umount: %s added!\n", buf);
 		list_add(&new_entry->list, &mount_list);
-		ksu_unmountable_count++;
 
 		if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
 			pr_err("prctl reply error, cmd: %lu\n", arg2);
@@ -676,10 +674,6 @@ int ksu_handle_setuid(struct cred *new, const struct cred *old)
 		return 0;
 	}
 
-	// we dont need to unmount if theres no unmountable
-	if (!ksu_unmountable_count)
-		return 0;
-
 	if (!new || !old) {
 		return 0;
 	}
-- 
2.51.1.dirty


From c760ab8b1a1194c663e57c85492c4dcc734154a3 Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:01:21 +0800
Subject: [PATCH 09/11] Revert "kernel: core_hook: add wipe umount list cmd"

This reverts commit a8464c19d5fa43937b32e117e8bb26714483f75a.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/core_hook.c | 16 ----------------
 kernel/ksu.h       |  1 -
 2 files changed, 17 deletions(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index bd699399..4fa28a4f 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -296,22 +296,6 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 	pr_info("option: 0x%x, cmd: %ld\n", option, arg2);
 #endif
 
-	if (arg2 == CMD_WIPE_UMOUNT_LIST) {
-		struct mount_entry *entry, *tmp;
-		list_for_each_entry_safe(entry, tmp, &mount_list, list) {
-			pr_info("wipe_umount_list: removing entry: %s\n", entry->umountable);
-			list_del(&entry->list);
-			kfree(entry->umountable);
-			kfree(entry);
-        	}
-        	ksu_unmountable_count = 0;
-
-		if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
-			pr_err("prctl reply error, cmd: %lu\n", arg2);
-		}
-		return 0;
-	}
-
 	if (arg2 == CMD_ADD_TRY_UMOUNT) {
 		struct mount_entry *new_entry, *entry;
 		char buf[384];
diff --git a/kernel/ksu.h b/kernel/ksu.h
index b16d4424..d40a8049 100644
--- a/kernel/ksu.h
+++ b/kernel/ksu.h
@@ -25,7 +25,6 @@
 #define CMD_ENABLE_SU 15
 #define CMD_GET_MANAGER_UID 16
 
-#define CMD_WIPE_UMOUNT_LIST 10000
 #define CMD_ADD_TRY_UMOUNT 10001
 #define CMD_NUKE_EXT4_SYSFS 10002
 #define CMD_TOGGLE_AVC_SPOOF 10003
-- 
2.51.1.dirty


From 208af17eccca54fe1936dea265991155bb66775d Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:04:17 +0800
Subject: [PATCH 10/11] Revert "kernel: core_hook: expose prctl interface for
 umount list (5ec1cff#16)"

This reverts commit a9f990fb679fd310e49c872396fcf60c95127fdd.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/core_hook.c | 99 ++++++++++++++++++++--------------------------
 kernel/ksu.h       |  1 -
 2 files changed, 42 insertions(+), 58 deletions(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index 4fa28a4f..88847587 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -259,12 +259,6 @@ static void nuke_ext4_sysfs(const char *custompath) {
 	path_put(&path);
 }
 
-struct mount_entry {
-    char *umountable;
-    struct list_head list;
-};
-LIST_HEAD(mount_list);
-
 int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 		     unsigned long arg4, unsigned long arg5)
 {
@@ -296,47 +290,6 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 	pr_info("option: 0x%x, cmd: %ld\n", option, arg2);
 #endif
 
-	if (arg2 == CMD_ADD_TRY_UMOUNT) {
-		struct mount_entry *new_entry, *entry;
-		char buf[384];
-
-		if (copy_from_user(buf, (const char __user *)arg3, sizeof(buf) - 1)) {
-			pr_err("cmd_add_try_umount: failed to copy user string\n");
-			return 0;
-		}
-		buf[384 - 1] = '\0';
-
-		new_entry = kmalloc(sizeof(*new_entry), GFP_KERNEL);
-		if (!new_entry)
-			return 0;
-
-		new_entry->umountable = kstrdup(buf, GFP_KERNEL);
-		if (!new_entry->umountable) {
-			kfree(new_entry);
-			return 0;
-		}
-
-		// disallow dupes
-		// if this gets too many, we can consider moving this whole task to a kthread
-		list_for_each_entry(entry, &mount_list, list) {
-			if (!strcmp(entry->umountable, buf)) {
-				pr_info("cmd_add_try_umount: %s is already here!\n", buf);
-				kfree(new_entry->umountable);
-				kfree(new_entry);
-				return 0;
-			}	
-		}	
-
-		// debug
-		// pr_info("cmd_add_try_umount: %s added!\n", buf);
-		list_add(&new_entry->list, &mount_list);
-
-		if (copy_to_user(result, &reply_ok, sizeof(reply_ok))) {
-			pr_err("prctl reply error, cmd: %lu\n", arg2);
-		}
-		return 0;
-	}
-
 	if (arg2 == CMD_NUKE_EXT4_SYSFS) {
 		char buf[384];
 
@@ -626,13 +579,34 @@ static bool is_non_appuid(kuid_t uid)
 	return appid < FIRST_APPLICATION_UID;
 }
 
-static void ksu_path_umount(const char *mnt, struct path *path, int flags)
+static bool should_umount(struct path *path)
+{
+	if (!path) {
+		return false;
+	}
+
+	if (current->nsproxy->mnt_ns == init_nsproxy.mnt_ns) {
+		pr_info("ignore global mnt namespace process: %d\n",
+			current_uid().val);
+		return false;
+	}
+
+	if (path->mnt && path->mnt->mnt_sb && path->mnt->mnt_sb->s_type) {
+		const char *fstype = path->mnt->mnt_sb->s_type->name;
+		return strcmp(fstype, "overlay") == 0;
+	}
+	return false;
+}
+
+static void ksu_umount_mnt(struct path *path, int flags)
 {
 	int err = path_umount(path, flags);
-	pr_info("%s: path: %s code: %d\n", __func__, mnt, err);
+	if (err) {
+		pr_info("umount %s failed: %d\n", path->dentry->d_iname, err);
+	}
 }
 
-static void try_umount(const char *mnt, int flags)
+static void try_umount(const char *mnt, bool check_mnt, int flags)
 {
 	struct path path;
 	int err = kern_path(mnt, 0, &path);
@@ -646,13 +620,17 @@ static void try_umount(const char *mnt, int flags)
 		return;
 	}
 
-	ksu_path_umount(mnt, &path, flags);
+	// we are only interest in some specific mounts
+	if (check_mnt && !should_umount(&path)) {
+		path_put(&path);
+		return;
+	}
+
+	ksu_umount_mnt(&path, flags);
 }
 
 int ksu_handle_setuid(struct cred *new, const struct cred *old)
 {
-	struct mount_entry *entry;
-
 	// this hook is used for umounting overlayfs for some uid, if there isn't any module mounted, just ignore it!
 	if (!ksu_module_mounted) {
 		return 0;
@@ -715,10 +693,17 @@ do_umount:
 		current->pid);
 #endif
 
-	// don't free! keep on heap! this is used on subsequent setuid calls
-	// if this is freed, we dont have anything to umount next
-	list_for_each_entry(entry, &mount_list, list)
-		try_umount(entry->umountable, MNT_DETACH);
+	// fixme: use `collect_mounts` and `iterate_mount` to iterate all mountpoint and
+	// filter the mountpoint whose target is `/data/adb`
+	try_umount("/odm", true, 0);
+	try_umount("/system", true, 0);
+	try_umount("/vendor", true, 0);
+	try_umount("/product", true, 0);
+	try_umount("/system_ext", true, 0);
+	try_umount("/data/adb/modules", false, MNT_DETACH);
+
+	// try umount ksu temp path
+	try_umount("/debug_ramdisk", false, MNT_DETACH);
 
 	return 0;
 }
diff --git a/kernel/ksu.h b/kernel/ksu.h
index d40a8049..2a694618 100644
--- a/kernel/ksu.h
+++ b/kernel/ksu.h
@@ -25,7 +25,6 @@
 #define CMD_ENABLE_SU 15
 #define CMD_GET_MANAGER_UID 16
 
-#define CMD_ADD_TRY_UMOUNT 10001
 #define CMD_NUKE_EXT4_SYSFS 10002
 #define CMD_TOGGLE_AVC_SPOOF 10003
 #define CMD_IS_AVC_SPOOF_ENABLED 10004
-- 
2.51.1.dirty


From f053f171b6648949368a1ca973b211e8aac01c30 Mon Sep 17 00:00:00 2001
From: KOWX712 <leecc0503@gmail.com>
Date: Mon, 20 Oct 2025 10:04:38 +0800
Subject: [PATCH 11/11] Revert "Unmount isolated process which forks from
 zygote (tiann#2776)"

This reverts commit c233f23677e8058681d08c30f961e12a78ad030d.

Signed-off-by: KOWX712 <leecc0503@gmail.com>
---
 kernel/core_hook.c | 29 +++++++++--------------------
 1 file changed, 9 insertions(+), 20 deletions(-)

diff --git a/kernel/core_hook.c b/kernel/core_hook.c
index 88847587..40b75f3c 100644
--- a/kernel/core_hook.c
+++ b/kernel/core_hook.c
@@ -73,7 +73,7 @@ static inline bool is_allow_su()
 	return ksu_is_allow_uid(current_uid().val);
 }
 
-static inline bool is_unsupported_app_uid(uid_t uid)
+static inline bool is_unsupported_uid(uid_t uid)
 {
 #define LAST_APPLICATION_UID 19999
 	uid_t appid = uid % 100000;
@@ -570,13 +570,14 @@ int ksu_handle_prctl(int option, unsigned long arg2, unsigned long arg3,
 	return 0;
 }
 
-static bool is_non_appuid(kuid_t uid)
+static bool is_appuid(kuid_t uid)
 {
 #define PER_USER_RANGE 100000
 #define FIRST_APPLICATION_UID 10000
+#define LAST_APPLICATION_UID 19999
 
 	uid_t appid = uid.val % PER_USER_RANGE;
-	return appid < FIRST_APPLICATION_UID;
+	return appid >= FIRST_APPLICATION_UID && appid <= LAST_APPLICATION_UID;
 }
 
 static bool should_umount(struct path *path)
@@ -648,25 +649,13 @@ int ksu_handle_setuid(struct cred *new, const struct cred *old)
 		return 0;
 	}
 
-	if (is_non_appuid(new_uid)) {
-#ifdef CONFIG_KSU_DEBUG
-		pr_info("handle setuid ignore non application uid: %d\n", new_uid.val);
-#endif
+	if (!is_appuid(new_uid) || is_unsupported_uid(new_uid.val)) {
+		// pr_info("handle setuid ignore non application or isolated uid: %d\n", new_uid.val);
 		return 0;
 	}
 
-	// isolated process may be directly forked from zygote, always unmount
-	if (is_unsupported_app_uid(new_uid.val)) {
-#ifdef CONFIG_KSU_DEBUG
-		pr_info("handle umount for unsupported application uid: %d\n", new_uid.val);
-#endif
-		goto do_umount;
-	}
-
 	if (ksu_is_allow_uid(new_uid.val)) {
-#ifdef CONFIG_KSU_DEBUG
-		pr_info("handle setuid ignore allowed application: %d\n", new_uid.val);
-#endif
+		// pr_info("handle setuid ignore allowed application: %d\n", new_uid.val);
 		return 0;
 	}
 
@@ -678,11 +667,11 @@ int ksu_handle_setuid(struct cred *new, const struct cred *old)
 #endif
 	}
 
-do_umount:
 	// check old process's selinux context, if it is not zygote, ignore it!
 	// because some su apps may setuid to untrusted_app but they are in global mount namespace
 	// when we umount for such process, that is a disaster!
-	if (!is_zygote(old->security)) {
+	bool is_zygote_child = is_zygote(old->security);
+	if (!is_zygote_child) {
 		pr_info("handle umount ignore non zygote child: %d\n",
 			current->pid);
 		return 0;
-- 
2.51.1.dirty

