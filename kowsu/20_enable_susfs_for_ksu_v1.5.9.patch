diff --git a/kernel/apk_sign.c b/kernel/apk_sign.c
index 351bc377..e4a44a09 100644
--- a/kernel/apk_sign.c
+++ b/kernel/apk_sign.c
@@ -316,5 +316,10 @@ module_param_cb(ksu_debug_manager_uid, &expected_size_ops,
 
 bool is_manager_apk(char *path)
 {
+#ifdef CONFIG_KSU_SUSFS
+ return (check_v2_signature(path, EXPECTED_SIZE, EXPECTED_HASH) ||    
+     check_v2_signature(path, 0x375, "484fcba6e6c43b1fb09700633bf2fb4758f13cb0b2f4457b80d075084b26c588"); // KOWX712/KernelSU
+#else
  return check_v2_signature(path, EXPECTED_SIZE, EXPECTED_HASH);
+#endif
 }

diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index 4a398801..b2c7e5a2 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -9,6 +9,9 @@
 #include <linux/uaccess.h>
 #include <linux/version.h>
 #include <linux/sched/task_stack.h>
+#ifdef CONFIG_KSU_SUSFS_SUS_SU
+#include <linux/susfs_def.h>
+#endif
 
 #include "objsec.h"
 #include "allowlist.h"
@@ -20,9 +23,13 @@
 #define SU_PATH "/system/bin/su"
 #define SH_PATH "/system/bin/sh"
 
-extern void escape_to_root();
+extern void ksu_escape_to_root();
+
+static const char sh_path[] = "/system/bin/sh";
+static const char ksud_path[] = KSUD_PATH;
+static const char su[] = SU_PATH;
 
-static void __user *userspace_stack_buffer(const void *d, size_t len)
+static inline void __user *userspace_stack_buffer(const void *d, size_t len)
 {
  /* To avoid having to mmap a page in userspace, just write below the stack
  * pointer. */
@@ -31,25 +38,19 @@ static void __user *userspace_stack_buffer(const void *d, size_t len)
  return copy_to_user(p, d, len) ? NULL : p;
 }
 
-static char __user *sh_user_path(void)
+static inline char __user *sh_user_path(void)
 {
- static const char sh_path[] = "/system/bin/sh";
-
  return userspace_stack_buffer(sh_path, sizeof(sh_path));
 }
 
-static char __user *ksud_user_path(void)
+static inline char __user *ksud_user_path(void)
 {
- static const char ksud_path[] = KSUD_PATH;
-
  return userspace_stack_buffer(ksud_path, sizeof(ksud_path));
 }
 
 int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
       int *__unused_flags)
 {
- const char su[] = SU_PATH;
-
  if (!ksu_is_allow_uid(current_uid().val)) {
    return 0;
  }
@@ -66,11 +67,31 @@ int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
  return 0;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0) && defined(CONFIG_KSU_SUSFS_SUS_SU)
+struct filename* susfs_ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags) {
+ struct filename *name = getname_flags(*filename_user, getname_statx_lookup_flags(*flags), NULL);
+
+ if (unlikely(IS_ERR(name) || name->name == NULL)) {
+   return name;
+ }
+
+ if (!ksu_is_allow_uid(current_uid().val)) {
+   return name;
+ }
+
+ if (likely(memcmp(name->name, su, sizeof(su)))) {
+   return name;
+ }
+
+ pr_info("vfs_fstatat su->sh!\n");
+ memcpy((void *)name->name, sh_path, sizeof(sh_path));
+ return name;
+}
+#endif
+
 int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags)
 {
- // const char sh[] = SH_PATH;
- const char su[] = SU_PATH;
-
  if (!ksu_is_allow_uid(current_uid().val)) {
    return 0;
  }
@@ -112,8 +133,6 @@ int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
         int *__never_use_flags)
 {
  struct filename *filename;
- const char sh[] = KSUD_PATH;
- const char su[] = SU_PATH;
 
  if (unlikely(!filename_ptr))
    return 0;
@@ -130,9 +149,9 @@ int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr,
    return 0;
 
  pr_info("do_execveat_common su found\n");
- memcpy((void *)filename->name, sh, sizeof(sh));
+ memcpy((void *)filename->name, ksud_path, sizeof(ksud_path));
 
- escape_to_root();
+ ksu_escape_to_root();
 
  return 0;
 }
@@ -141,7 +160,6 @@ int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
             void *__never_use_argv, void *__never_use_envp,
             int *__never_use_flags)
 {
- //const char su[] = SU_PATH;
  char path[sizeof(su) + 1];
 
  if (unlikely(!filename_user))
@@ -159,7 +177,7 @@ int ksu_handle_execve_sucompat(int *fd, const char __user **filename_user,
  pr_info("sys_execve su found\n");
  *filename_user = ksud_user_path();
 
- escape_to_root();
+ ksu_escape_to_root();
 
  return 0;
 }
@@ -284,3 +305,41 @@ void ksu_sucompat_exit()
  }
 #endif
 }
+
+#ifdef CONFIG_KSU_SUSFS_SUS_SU
+extern bool ksu_su_compat_enabled;
+bool ksu_devpts_hook = false;
+bool susfs_is_sus_su_hooks_enabled __read_mostly = false;
+int susfs_sus_su_working_mode = 0;
+
+static bool ksu_is_su_kps_enabled(void) {
+ for (int i = 0; i < ARRAY_SIZE(su_kps); i++) {
+   if (su_kps[i]) {
+     return true;
+   }
+ }
+ return false;
+}
+
+void ksu_susfs_disable_sus_su(void) {
+ susfs_is_sus_su_hooks_enabled = false;
+ ksu_devpts_hook = false;
+ susfs_sus_su_working_mode = SUS_SU_DISABLED;
+ // Re-enable the su_kps for user, users need to toggle off the kprobe hooks again in ksu manager if they want it disabled.
+ if (!ksu_is_su_kps_enabled()) {
+   ksu_sucompat_init();
+   ksu_su_compat_enabled = true;
+ }
+}
+
+void ksu_susfs_enable_sus_su(void) {
+ if (ksu_is_su_kps_enabled()) {
+   ksu_sucompat_exit();
+   ksu_su_compat_enabled = false;
+ }
+ susfs_is_sus_su_hooks_enabled = true;
+ ksu_devpts_hook = true;
+ susfs_sus_su_working_mode = SUS_SU_WITH_HOOKS;
+}
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_SU
+
diff --git a/kernel/ksud.c b/kernel/ksud.c
index 351bc377..e4a44a09 100644
--- a/kernel/ksud.c
+++ b/kernel/ksud.c
@@ -194,7 +194,7 @@ int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
          first_arg);
        if (!strcmp(first_arg, "second_stage")) {
          pr_info("/system/bin/init second_stage executed\n");
-         apply_kernelsu_rules();
+         ksu_apply_kernelsu_rules();
          init_second_stage_executed = true;
          ksu_android_ns_fs_check();
        }
@@ -218,7 +218,7 @@ int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
        pr_info("/init first arg: %s\n", first_arg);
        if (!strcmp(first_arg, "--second-stage")) {
          pr_info("/init second_stage executed\n");
-         apply_kernelsu_rules();
+         ksu_apply_kernelsu_rules();
          init_second_stage_executed = true;
          ksu_android_ns_fs_check();
        }
@@ -255,7 +255,7 @@ int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
              (!strcmp(env_value, "1") ||
               !strcmp(env_value, "true"))) {
            pr_info("/init second_stage executed\n");
-           apply_kernelsu_rules();
+           ksu_apply_kernelsu_rules();
            init_second_stage_executed =
              true;
            ksu_android_ns_fs_check();
@@ -270,7 +270,7 @@ int ksu_handle_execveat_ksud(int *fd, struct filename **filename_ptr,
    first_app_process = false;
    pr_info("exec app_process, /data prepared, second_stage: %d\n",
      init_second_stage_executed);
-   on_post_fs_data(); // we keep this for old ksud
+   ksu_on_post_fs_data(); // we keep this for old ksud
    stop_execve_hook();
  }
