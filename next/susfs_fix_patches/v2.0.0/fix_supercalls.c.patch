diff --git a/kernel/supercalls.c b/kernel/supercalls.c
index 22e22cf..941900f 100644
--- a/kernel/supercalls.c
+++ b/kernel/supercalls.c
@@ -123,6 +123,9 @@ static int do_report_event(void __user *arg)
 			boot_complete_lock = true;
 			pr_info("boot_complete triggered\n");
 			on_boot_completed();
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+			susfs_is_boot_completed_triggered = true;
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 		}
 		break;
 	}
@@ -414,6 +417,7 @@ static int do_manage_mark(void __user *arg)
 
 	switch (cmd.operation) {
 	case KSU_MARK_GET: {
+#ifndef CONFIG_KSU_SUSFS
 		// Get task mark status
 		ret = ksu_get_task_mark(cmd.pid);
 		if (ret < 0) {
@@ -422,8 +426,19 @@ static int do_manage_mark(void __user *arg)
 		}
 		cmd.result = (u32)ret;
 		break;
+#else
+		if (susfs_is_current_proc_umounted()) {
+			ret = 0; // SYSCALL_TRACEPOINT is NOT flagged
+		} else {
+			ret = 1; // SYSCALL_TRACEPOINT is flagged
+		}
+		pr_info("manage_mark: ret for pid %d: %d\n", cmd.pid, ret);
+		cmd.result = (u32)ret;
+		break;
+#endif // #ifndef CONFIG_KSU_SUSFS
 	}
 	case KSU_MARK_MARK: {
+#ifndef CONFIG_KSU_SUSFS
 		if (cmd.pid == 0) {
 			ksu_mark_all_process();
 		} else {
@@ -434,9 +449,15 @@ static int do_manage_mark(void __user *arg)
 				return ret;
 			}
 		}
+#else
+		if (cmd.pid != 0) {
+			return ret;
+		}
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	case KSU_MARK_UNMARK: {
+#ifndef CONFIG_KSU_SUSFS
 		if (cmd.pid == 0) {
 			ksu_unmark_all_process();
 		} else {
@@ -447,11 +468,20 @@ static int do_manage_mark(void __user *arg)
 				return ret;
 			}
 		}
+#else
+		if (cmd.pid != 0) {
+			return ret;
+		}
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	case KSU_MARK_REFRESH: {
+#ifndef CONFIG_KSU_SUSFS
 		ksu_mark_running_process();
 		pr_info("manage_mark: refreshed running processes\n");
+#else
+		pr_info("susfs: cmd: KSU_MARK_REFRESH: do nothing\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	default: {
@@ -623,6 +653,55 @@ static int add_try_umount(void __user *arg)
         return 0;
     }
 
+	// this way userspace can deduce the memory it has to prepare.
+	case KSU_UMOUNT_GETSIZE: {
+		// check for pointer first
+		if (!cmd.arg)
+			return -EFAULT;
+	
+		size_t total_size = 0; // size of list in bytes
+
+		down_read(&mount_list_lock);
+		list_for_each_entry(entry, &mount_list, list) {
+			total_size = total_size + strlen(entry->umountable) + 1; // + 1 for \0
+		}
+		up_read(&mount_list_lock);
+
+		pr_info("cmd_add_try_umount: total_size: %zu\n", total_size);
+		
+		if (copy_to_user((size_t __user *)cmd.arg, &total_size, sizeof(total_size)))
+			return -EFAULT;
+
+		return 0;
+	}
+	
+	// WARNING! this is straight up pointerwalking.
+	// this way we dont need to redefine the ioctl defs.
+	// this also avoids us needing to kmalloc
+	// userspace have to send pointer to memory (malloc/alloca) or pointer to a VLA.
+	case KSU_UMOUNT_GETLIST: {
+		if (!cmd.arg)
+			return -EFAULT;
+		
+		void *user_buf = (void *)cmd.arg;
+
+		down_read(&mount_list_lock);
+		list_for_each_entry(entry, &mount_list, list) {
+			pr_info("cmd_add_try_umount: entry: %s\n", entry->umountable);
+		
+			if (copy_to_user(user_buf, entry->umountable, strlen(entry->umountable) + 1 )) {
+				up_read(&mount_list_lock);
+				return -EFAULT;
+			}
+			
+			// walk it! +1 for null terminator
+			user_buf = user_buf + strlen(entry->umountable) + 1;
+		}
+		up_read(&mount_list_lock);
+
+		return 0;
+	}
+
     default: {
         pr_err("cmd_add_try_umount: invalid operation %u\n", cmd.mode);
         return -EINVAL;
@@ -807,6 +886,31 @@ int ksu_handle_sys_reboot(int magic1, int magic2, unsigned int cmd, void __user
         return -EINVAL; 
     }
 
+	if (magic2 == CHANGE_MANAGER_UID) {
+		/* only root is allowed for this command */
+		if (current_uid().val != 0)
+			return 0;
+
+		pr_info("ksu_handle_sys_reboot: ksu_set_manager_appid to: %d\n", cmd);
+		ksu_set_manager_appid(cmd);
+
+		if (cmd == ksu_get_manager_appid()) {
+			unsigned long reply = (unsigned long)*arg;
+			if (copy_to_user((void __user *)*arg, &reply, sizeof(reply)))
+				pr_info("ksu_handle_sys_reboot: reply fail\n");
+		}
+
+		return 0;
+	}
+
+	if (magic2 == GET_SULOG_DUMP) {
+		if (current_uid().val != 0)
+			return 0;
+
+		send_sulog_dump((void __user *)*arg);
+		return 0;
+	}
+
     // If magic2 is susfs and current process is root
     if (magic2 == SUSFS_MAGIC && current_uid().val == 0) {
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
@@ -925,18 +1029,21 @@ void ksu_supercalls_init(void)
         pr_info("  %-18s = 0x%08x\n", ksu_ioctl_handlers[i].name,
                 ksu_ioctl_handlers[i].cmd);
     }
-
+#ifndef CONFIG_KSU_SUSFS
 	int rc = register_kprobe(&reboot_kp);
 	if (rc) {
 		pr_err("reboot kprobe failed: %d\n", rc);
 	} else {
 		pr_info("reboot kprobe registered successfully\n");
 	}
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 void ksu_supercalls_exit(void)
 {
+#ifndef CONFIG_KSU_SUSFS
     unregister_kprobe(&reboot_kp);
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 // IOCTL dispatcher
diff --git a/kernel/supercalls.h b/kernel/supercalls.h
index e82de28..be71211 100644
--- a/kernel/supercalls.h
+++ b/kernel/supercalls.h
@@ -12,6 +12,8 @@
 // Toolkit extensions
 #define CHANGE_MANAGER_UID 10006
 #define GET_SULOG_DUMP 10009
+#define KSU_UMOUNT_GETSIZE 107   // get list size // shit is u8 we cant fit 10k+ on it
+#define KSU_UMOUNT_GETLIST 108   // get list
 
 // Command structures for ioctl
 
