diff --git a/kernel/supercalls.c b/kernel/supercalls.c
index da39800..1229b02 100644
--- a/kernel/supercalls.c
+++ b/kernel/supercalls.c
@@ -123,6 +123,9 @@ static int do_report_event(void __user *arg)
 			boot_complete_lock = true;
 			pr_info("boot_complete triggered\n");
 			on_boot_completed();
+#ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
+			susfs_is_boot_completed_triggered = true;
+#endif // #ifdef CONFIG_KSU_SUSFS_SUS_MOUNT
 		}
 		break;
 	}
@@ -414,6 +418,7 @@ static int do_manage_mark(void __user *arg)
 
 	switch (cmd.operation) {
 	case KSU_MARK_GET: {
+#ifndef CONFIG_KSU_SUSFS
 		// Get task mark status
 		ret = ksu_get_task_mark(cmd.pid);
 		if (ret < 0) {
@@ -422,8 +427,19 @@ static int do_manage_mark(void __user *arg)
 		}
 		cmd.result = (u32)ret;
 		break;
+#else
+		if (susfs_is_current_proc_umounted()) {
+			ret = 0; // SYSCALL_TRACEPOINT is NOT flagged
+		} else {
+			ret = 1; // SYSCALL_TRACEPOINT is flagged
+		}
+		pr_info("manage_mark: ret for pid %d: %d\n", cmd.pid, ret);
+		cmd.result = (u32)ret;
+		break;
+#endif // #ifndef CONFIG_KSU_SUSFS
 	}
 	case KSU_MARK_MARK: {
+#ifndef CONFIG_KSU_SUSFS
 		if (cmd.pid == 0) {
 			ksu_mark_all_process();
 		} else {
@@ -434,9 +444,15 @@ static int do_manage_mark(void __user *arg)
 				return ret;
 			}
 		}
+#else
+		if (cmd.pid != 0) {
+			return 0;
+		}
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	case KSU_MARK_UNMARK: {
+#ifndef CONFIG_KSU_SUSFS
 		if (cmd.pid == 0) {
 			ksu_unmark_all_process();
 		} else {
@@ -447,11 +463,20 @@ static int do_manage_mark(void __user *arg)
 				return ret;
 			}
 		}
+#else
+		if (cmd.pid != 0) {
+			return 0;
+		}
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	case KSU_MARK_REFRESH: {
+#ifndef CONFIG_KSU_SUSFS
 		ksu_mark_running_process();
 		pr_info("manage_mark: refreshed running processes\n");
+#else
+		pr_info("susfs: cmd: KSU_MARK_REFRESH: do nothing\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 		break;
 	}
 	default: {
@@ -471,7 +496,7 @@ static int do_get_hook_mode(void __user *arg)
 {
 	struct ksu_get_hook_mode_cmd cmd = {0};
 
-	strscpy(cmd.mode, "Kprobes", sizeof(cmd.mode));
+	strscpy(cmd.mode, "Manual", sizeof(cmd.mode));
 
 	if (copy_to_user(arg, &cmd, sizeof(cmd))) {
 		pr_err("get_hook_mode: copy_to_user failed\n");
@@ -807,6 +832,31 @@ int ksu_handle_sys_reboot(int magic1, int magic2, unsigned int cmd, void __user
         return -EINVAL; 
     }
 
+	if (magic2 == CHANGE_MANAGER_UID) {
+		/* only root is allowed for this command */
+		if (current_uid().val != 0)
+			return 0;
+
+		pr_info("ksu_handle_sys_reboot: ksu_set_manager_appid to: %d\n", cmd);
+		ksu_set_manager_appid(cmd);
+
+		if (cmd == ksu_get_manager_appid()) {
+			unsigned long reply = (unsigned long)*arg;
+			if (copy_to_user((void __user *)*arg, &reply, sizeof(reply)))
+				pr_info("ksu_handle_sys_reboot: reply fail\n");
+		}
+
+		return 0;
+	}
+
+	if (magic2 == GET_SULOG_DUMP) {
+		if (current_uid().val != 0)
+			return 0;
+
+		send_sulog_dump((void __user *)*arg);
+		return 0;
+	}
+
     // If magic2 is susfs and current process is root
     if (magic2 == SUSFS_MAGIC && current_uid().val == 0) {
 #ifdef CONFIG_KSU_SUSFS_SUS_PATH
@@ -918,18 +973,23 @@ void ksu_supercalls_init(void)
         pr_info("  %-18s = 0x%08x\n", ksu_ioctl_handlers[i].name,
                 ksu_ioctl_handlers[i].cmd);
     }
-
+#ifndef CONFIG_KSU_SUSFS
 	int rc = register_kprobe(&reboot_kp);
 	if (rc) {
 		pr_err("reboot kprobe failed: %d\n", rc);
 	} else {
 		pr_info("reboot kprobe registered successfully\n");
 	}
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 void ksu_supercalls_exit(void)
 {
-    unregister_kprobe(&reboot_kp);
+#ifndef CONFIG_KSU_SUSFS
+	unregister_kprobe(&reboot_kp);
+#else
+	pr_info("susfs: do nothing\n");
+#endif // #ifndef CONFIG_KSU_SUSFS
 }
 
 // IOCTL dispatcher
